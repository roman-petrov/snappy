---
description:
  TypeScript coding style (type inference, naming, undefined, ===, braces, type not interface, arrow functions, barrel
  files, export/import from index only). Builds on programming rule. Use when writing or reviewing TypeScript code.
globs: "**/*.{ts,tsx}"
alwaysApply: false
---

# üìò TypeScript

Follow the **programming** rule for general principles (DRY, pure functions, no OOP, comments, simple names, etc.). This
rule adds TypeScript-specific rules only.

---

## üìÅ Project & files

### File naming

Use **PascalCase** for `.ts` and `.tsx` files. _Exceptions_ (keep as-is): `main`, `index`, `entry-*` (e.g.
`entry-client.tsx`, `entry-server.tsx`), and the **locales** folder and its files (e.g. `locales/en.ts`,
`locales/ru.ts`).

---

## üè∑ Naming conventions

- **Types**: `PascalCase`
- **Regular variables**: `camelCase`
- **Exported variables**: `PascalCase`
- **Parameters**: `camelCase`
- **Properties and methods in object literals**: `camelCase`
- leading and trailing underscores are **forbidden**, except for unused parameters.

---

## üìê Types

### Infer types from values

Prefer **inferring types from values** so data and types stay in sync. Annotate explicitly only when inference is
impossible or hurts readability.

| Situation                     | How to infer                                               |
| ----------------------------- | ---------------------------------------------------------- |
| Literal array/tuple           | `const X = [...] as const` ‚Üí `type T = (typeof X)[number]` |
| Constant object (keys/values) | `keyof typeof OBJ`, `(typeof OBJ)[key]`                    |
| Function return type          | `ReturnType<typeof fn>`                                    |
| Function parameters           | `Parameters<typeof fn>`                                    |

```ts
const statuses = ["pending", "done", "failed"] as const;
type Status = (typeof statuses)[number];

const config = { timeout: 5000, retries: 3 } as const;
type ConfigKey = keyof typeof config;
```

### Type declarations

- Use only **`type`**, not `interface`.
- **Don't specify types** where the compiler infers them.

### undefined instead of null

- Don't use `null`; use **`undefined`** for "absent" values.
- Replace `T | null` with `T | undefined` (or optional field without explicit type).

---

## ‚ö° Functions

### Arrow functions

- Use **arrow functions** everywhere, not regular `function`.

### Destructure parameters

When possible, **destructure function parameters** instead of accessing properties via the parameter name. Prefer
`({ a, b }: Props)` over `(props: Props)` with `props.a`, `props.b` in the body.

```ts
type Options = { a: string; b: number };

const fn = ({ a, b }: Options) => a + b;
```

### Destructure assignments

When assigning from an object, **destructure needed properties** instead of assigning the whole object and then
accessing properties. Prefer `const { a, b } = obj` over `const x = obj` with `x.a`, `x.b`.

```ts
const { a, b } = obj;
```

---

## üîÄ Control flow & expressions

### Strict comparison

- Always use **`===`** and **`!==`**, not `==` / `!=`.

### Braces in conditionals

- In **`if`** (and in `else`, `else if`) always use **curly braces**, even for a single statement.

### Ternary over multiple return branches

Prefer a **single return with ternary** over several `if` branches that each return a value.

```ts
// Bad: multiple if-return branches
const label = (status: Status) => {
  if (status === "pending") return "Waiting";
  if (status === "done") return "Complete";
  return "Unknown";
};

// Good: one ternary expression
const label = (status: Status) => (status === "pending" ? "Waiting" : status === "done" ? "Complete" : "Unknown");
```

---

## üì¶ Modules

### Barrel files & import/export

- **Export all modules** from packages and directories.
- Use **barrel files** (`index.ts`) in every directory.
- In `index.ts`: list all files with `export * from "./File"` (and subfolders with `export * from "./folder"`). **Do
  not** re-export individual types or constants by name; use only `export *`.
- In parent directories: export everything from child directories and from the current directory ‚Äî
  `export * from "./folder1"`, `export * from "./folder2"`, `export * from "./File"`, etc.
- **Always import from barrel files** (e.g. `from "@repo/package"` or `from "./components"`), never from the concrete
  file (e.g. not `from "./components/Button"`).

### Module scope

- Don't use **`let`** at module level (only `const` or functions).

### Pure module (object of functions)

- Export as an **object of functions**: `export const <ModuleName> = { fn1, fn2, ... }`. Functions are declared in the
  same file.
- **Never export individual functions** ‚Äî only the single namespace constant (e.g.
  `export const Math = { add, remove }`, not `export function add` / `export const remove`).
- **Exception:** very general, frequently used helpers (e.g. localization `t`) may be exported and used without the
  module prefix.

```ts
const add = (a: number, b: number) => a + b;
const subtract = (a: number, b: number) => a - b;
const multiply = (a: number, b: number) => a * b;
const divide = (a: number, b: number) => a / b;

export const Math = { add, subtract, multiply, divide };
```

### Factory module (closure with side effects)

- Export as a **closure (factory)** that returns an API:
  `export const <ModuleName> = (deps?) => ({ method1, method2 })`.
- **Declare each function as a local `const` first**, then return the object. Don't inline arrow functions in the return
  literal ‚Äî extract them above the `return`.
- Export the API type: `export type <ModuleName> = ReturnType<typeof <ModuleName>>`.

```ts
export const Timer = (delay: number) => {
  let id: ReturnType<typeof setInterval> | undefined = undefined;

  const start = () => {
    id = setInterval(() => {}, delay);
  };

  const stop = () => {
    if (id !== undefined) {
      clearInterval(id);
      id = undefined;
    }
  };

  return { start, stop };
};

export type Timer = ReturnType<typeof Timer>;
```

---

## ‚úÖ Checklist

### Project & files

- [ ] Files in PascalCase (except `main`, `index`, `entry-*`, and `locales/` and its files)

### Types

- [ ] Types inferred from values where possible
- [ ] Only `type`, no `interface`
- [ ] Types omitted where inferred
- [ ] Use `undefined`, not `null`

### Functions

- [ ] Arrow functions everywhere
- [ ] Parameters destructured when possible (`({ a, b }: T)` not `(opts: T)` with `opts.a`)
- [ ] Assignments destructured when possible (`const { a } = obj` not `const x = obj` with `x.a`)

### Control flow & expressions

- [ ] Comparisons only `===` / `!==`
- [ ] All `if` statements have curly braces
- [ ] Ternary over multiple if-return branches when returning values

### Modules

- [ ] Barrel files in every directory; all modules exported from packages/directories
- [ ] In `index.ts`: only `export * from "./file"` / `export * from "./folder"`, no named exports of types/constants
- [ ] Parent directories re-export all children and current-dir files via `export *`
- [ ] Imports only from barrel files (package or directory), never from concrete files
- [ ] No `let` at module level (except in factory closure)
- [ ] Pure module: `export const X = { fn1, fn2 }` (no individual exports)
- [ ] Factory: functions declared as local `const` before `return`, not inlined
- [ ] Factory: API type exported as `export type X = ReturnType<typeof X>`
