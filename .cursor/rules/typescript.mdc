---
description:
  TypeScript coding style (type inference, naming, undefined, ===, braces, type not interface, arrow functions, module
  export conventions). Builds on programming rule. Use when writing or reviewing TypeScript code.
globs: "**/*.ts"
alwaysApply: false
---

# üìò TypeScript

Follow the **programming** rule for general principles (DRY, pure functions, no OOP, comments, simple names, etc.). This
rule adds TypeScript-specific rules only.

---

## üìê TypeScript-Specific Rules

### Infer types from values

Prefer **inferring types from values** so data and types stay in sync. Annotate explicitly only when inference is
impossible or hurts readability.

| Situation                     | How to infer                                               |
| ----------------------------- | ---------------------------------------------------------- |
| Literal array/tuple           | `const X = [...] as const` ‚Üí `type T = (typeof X)[number]` |
| Constant object (keys/values) | `keyof typeof OBJ`, `(typeof OBJ)[key]`                    |
| Function return type          | `ReturnType<typeof fn>`                                    |
| Function parameters           | `Parameters<typeof fn>`                                    |

```ts
const STATUSES = ["pending", "done", "failed"] as const;
type Status = (typeof STATUSES)[number];

const CONFIG = { timeout: 5000, retries: 3 } as const;
type ConfigKey = keyof typeof CONFIG;
```

### üìÅ File naming

Use **PascalCase** for `.ts` files; _exceptions_: `main.ts`, `index.ts`.

### undefined instead of null

- Don't use `null`; use **`undefined`** for "absent" values.
- Replace `T | null` with `T | undefined` (or optional field without explicit type).

### Strict comparison

- Always use **`===`** and **`!==`**, not `==` / `!=`.

### Braces in conditionals

- In **`if`** (and in `else`, `else if`) always use **curly braces**, even for a single statement.

### Types

- Use only **`type`**, not `interface`.
- **Don't specify types** where the compiler infers them.

### Arrow functions

- Use **arrow functions** everywhere, not regular `function`.

---

## üì¶ Module Export Rules

### No variables in module scope

- Don't use **`let`** at module level (only `const` or functions).

### Module of pure functions

Export as an **object of functions**: `export const <ModuleName> = { fn1, fn2, ... }`. Functions are declared in the
same file. **Never export individual functions** ‚Äî only the single namespace constant (e.g.
`export const Math = { add, remove }`, not `export function add` / `export const remove`). **Exception:** very general,
frequently used helpers (e.g. localization `t`) may be exported and used without the module prefix.

### Module with side effects

Export as a **closure (factory)** that returns an API: `export const <ModuleName> = (deps?) => ({ method1, method2 })`.
Inside ‚Äî `let` in the closure, reset via `undefined`, checks via `===` and braces in `if`.

```ts
export const Timer = (delay: number) => {
  let id: ReturnType<typeof setInterval> | undefined = undefined;
  const stop = () => {
    if (id !== undefined) {
      clearInterval(id);
      id = undefined;
    }
  };
  return { start, stop };
};
```

---

## ‚úÖ Checklist

- [ ] Types inferred from values where possible
- [ ] Files in PascalCase (except `main.ts`, `index.ts`)
- [ ] Use `undefined`, not `null`
- [ ] Comparisons only `===` / `!==`
- [ ] All `if` statements have curly braces
- [ ] Only `type`, no `interface`
- [ ] Types omitted where inferred
- [ ] Arrow functions everywhere
- [ ] No `let` at module level (except in factory closure)
- [ ] Pure module ‚Üí `export const X = { fn1, fn2 }` (no individual `export function`/`export const fn`); with side
      effects ‚Üí `export const X = (deps) => ({ ... })`
